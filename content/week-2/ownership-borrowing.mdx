---
title: "Ownership and Borrowing in Rust for Solana"
description: "Master Rust's ownership and borrowing rules to avoid common errors when working with Solana accounts in Anchor."
tags: ['rust', 'solana', 'anchor', 'ownership', 'borrowing']
module: '⚙️ Rust for Solana Developers'
---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';
import { File, Folder, Files } from 'fumadocs-ui/components/files';

If you’ve ever seen Rust errors like:  
`cannot borrow as mutable more than once at a time` or  
`value borrowed here after move`,  
you’ve run into **ownership** and **borrowing**.

On Solana, this is even more important because **accounts are just data in memory** if you accidentally break ownership rules, your program won’t even compile.

<Callout type="info">
By the end of this lesson, you’ll be able to:
- Explain Rust’s ownership model
- Pass accounts between functions without fighting the borrow checker
- Know when to use `&` and when to use `&mut`
- Understand why Anchor enforces these rules at compile time
</Callout>

---

## Why Ownership Matters for Solana

Solana programs run in a highly constrained environment:
- No shared mutable state between instructions
- Data is read from accounts, optionally mutated, then written back
- Multiple instructions may touch the same accounts

If two parts of your code could modify the same account at once, you’d risk **race conditions** and **data corruption**. Rust prevents this at compile time.

---

## Ownership Rules

Rust’s ownership rules boil down to three laws:

1. **Each value has a single owner.**
2. When the owner goes out of scope, the value is dropped.
3. You can have:
   - Multiple immutable references (`&T`) **or**
   - One mutable reference (`&mut T`)  but not both at the same time.

Here’s an example:

```rust title="main.rs"
fn main() {
    let account_data = String::from("Escrow State"); // Owner: main()
    println!("{}", account_data); // Reading is fine

    // Transferring ownership to another function
    print_data(account_data);

    // account_data is now invalid here
    // println!("{}", account_data); // ❌ compile error
}

fn print_data(data: String) {
    println!("{}", data);
} // data is dropped here
````

---

## Borrowing References

Instead of moving ownership, you can **borrow** data:

```rust title="main.rs"
fn main() {
    let account_data = String::from("Escrow State");

    // Immutable borrow
    print_data(&account_data);

    // account_data is still valid here
    println!("After borrow: {}", account_data);
}

fn print_data(data: &String) {
    println!("{}", data);
}
```

---

## Mutable Borrows

Mutable borrows let you change the value:

```rust title="main.rs"
fn main() {
    let mut amount: u64 = 100;
    increase_amount(&mut amount);
    println!("Updated amount: {}", amount);
}

fn increase_amount(num: &mut u64) {
    *num += 50;
}
```

**Key rule:**
You can only have **one mutable borrow** in a given scope, and no immutable borrows at the same time.

---

## How This Maps to Anchor

In Anchor, **mutable borrows** are used when you want to update account data:

```rust title="lib.rs"
pub fn update_balance(ctx: Context<Update>, amount: u64) -> Result<()> {
    let user_account = &mut ctx.accounts.user; // mutable borrow
    user_account.balance += amount;
    Ok(())
}
```

If you try to borrow `&mut ctx.accounts.user` twice in the same scope, you’ll get a compile error.

<Mermaid
chart="
graph TD;
A[Account Struct in Memory] --> B[Immutable Borrow &ctx.accounts.user]
A --> C[Mutable Borrow &mut ctx.accounts.user]
B -.X.-> C
C -.X.-> B
"
/>

---

## Example: Multiple Borrows Problem

```rust title="lib.rs"
pub fn risky_update(ctx: Context<Update>) -> Result<()> {
    let user_a = &mut ctx.accounts.user_a;
    let user_b = &mut ctx.accounts.user_b;

    if user_a.id == user_b.id {
        // ❌ Potential double-borrow of same account
    }

    Ok(())
}
```

Anchor prevents this because both borrows could point to the same account in memory.

---

## Immutable vs Mutable Access in Anchor

<Tabs items={['Immutable Example', 'Mutable Example']}> 

<Tab value="Immutable Example">

```rust title="lib.rs"
pub fn view_balance(ctx: Context<View>) -> Result<()> {
    let user_account = &ctx.accounts.user;
    msg!("Balance: {}", user_account.balance);
    Ok(())
}
```

</Tab>
<Tab value="Mutable Example">

```rust title="lib.rs"
pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
    let user_account = &mut ctx.accounts.user;
    user_account.balance += amount;
    Ok(())
}
```
</Tab>
</Tabs>

---

## Visualizing Ownership Flow

<Mermaid
chart="
sequenceDiagram
 participant Caller
 participant Program
 participant Account
 Caller->>Program: Pass account reference
 Program->>Account: Immutable borrow (&T) OR mutable borrow (&mut T)
 Note over Program,Account: Only one &mut allowed at a time
 Program-->>Caller: Return ownership after instruction
"
/>

---

## Try It Yourself

<Steps>
<Step>
### Step 1: Immutable Borrow
Write a function that takes `&String` and prints it.
</Step>
<Step>
### Step 2: Mutable Borrow
Write a function that takes `&mut u64` and adds 10.
</Step>
<Step>
### Step 3: Double Borrow Error
Try to take two `&mut` borrows of the same variable in one scope and observe the compile error.
</Step>
</Steps>

---

## Common Pitfalls

<Callout type="warn">
**Accidentally moving ownership**  
Passing a value without `&` moves ownership. For accounts, always use `&` or `&mut` unless you intentionally want to transfer ownership.
</Callout>

<Callout type="warn">
**Borrowing after move**  
Once ownership is moved, you cannot borrow the variable  it no longer exists in that scope.
</Callout>

<Callout type="warn">
**Mutable borrow conflicts**  
You can’t have a mutable borrow while immutable borrows exist. This includes temporary borrows from `println!` or logging macros.
</Callout>

---

## Summary

* Rust enforces ownership to ensure memory safety.
* Values can be moved, borrowed immutably (`&T`), or borrowed mutably (`&mut T`).
* Only one `&mut` borrow is allowed at a time, preventing race conditions.
* Anchor account references follow these same rules, so understanding ownership is critical for smart contract development.
* Borrowing rules are enforced at **compile time**, saving you from runtime bugs.

```

---

If you want, I can make **Day 3: Structs, Enums & Pattern Matching** even more detailed  including how `#[account]` maps to structs, how enums can model program states, and using `match` to branch logic in instructions. That’s where Rust syntax starts looking like real Anchor programs.  

Do you want me to move on to Day 3 now?