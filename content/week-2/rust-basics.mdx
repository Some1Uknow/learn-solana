---
title: Rust Basics
description: Learn the essential Rust syntax you need to read and write Solana programs. This covers variables, functions, basic types, and control flow - the building blocks for everything else.
type: lesson
module: ðŸ¦€ Rust for Solana
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';


<Callout type="info">
Learning goals:
- Understand Rust's variable declaration and mutability
- Write functions with parameters and return types
- Work with basic data types (integers, booleans, strings)
- Use control flow structures (if/else, loops)
- Understand Rust's expression-based syntax
</Callout>

---

## Variables and Mutability

In Rust, variables are immutable by default. You must explicitly make them mutable:

```rust
// Immutable (default)
let x = 5;
// x = 10; // This would cause an error!

// Mutable
let mut y = 5;
y = 10; // This works

// Type annotations (usually inferred)
let count: u32 = 42;
let is_ready: bool = true;
```

<Callout type="warn">
Unlike other languages, Rust variables are immutable by default. Always use `mut` when you need to change a variable's value.
</Callout>

---

## Basic Data Types

### Integers
```rust
// Unsigned integers
let small: u8 = 255;        // 0 to 255
let medium: u32 = 4_000_000; // Underscores for readability
let large: u64 = 18_446_744_073_709_551_615;

// Signed integers
let negative: i32 = -100;
let positive: i64 = 1_000_000;
```

### Booleans and Strings
```rust
let is_active: bool = true;
let is_complete: bool = false;

// String slice (most common for Solana)
let message: &str = "Hello Solana";

// Owned string
let owned_message: String = String::from("Hello World");
```

---

## Functions

Functions are declared with `fn` and use snake_case naming:

```rust
// Basic function
fn greet() {
    println!("Hello, Solana developer!");
}

// Function with parameters
fn add_numbers(a: u32, b: u32) -> u32 {
    a + b // No semicolon = return value
}

// Function with explicit return
fn multiply(a: u32, b: u32) -> u32 {
    return a * b; // Explicit return with semicolon
}

// Using the functions
fn main() {
    greet();
    let result = add_numbers(5, 3);
    println!("Result: {}", result);
}
```

<Callout type="info">
Notice that `a + b` doesn't have a semicolon. In Rust, expressions without semicolons are automatically returned from functions.
</Callout>

---

## Control Flow

### If/Else Statements
```rust
fn check_value(x: i32) {
    if x > 10 {
        println!("Big number");
    } else if x > 0 {
        println!("Small positive number");
    } else {
        println!("Zero or negative");
    }
}

// If as expression
fn get_status(count: u32) -> &'static str {
    if count > 100 {
        "high"
    } else {
        "low"
    }
}
```

### Loops
```rust
// Loop with break
fn count_up() {
    let mut counter = 0;
    loop {
        counter += 1;
        if counter == 5 {
            break;
        }
        println!("Counter: {}", counter);
    }
}

// While loop
fn count_down(mut n: i32) {
    while n > 0 {
        println!("{}", n);
        n -= 1;
    }
}

// For loop with range
fn print_range() {
    for i in 1..=5 {  // 1 to 5 inclusive
        println!("Number: {}", i);
    }
}
```

---

## Print and Debug

```rust
fn demonstrate_printing() {
    let name = "Alice";
    let age = 30;
    
    // Basic printing
    println!("Hello, world!");
    
    // With variables
    println!("Name: {}, Age: {}", name, age);
    
    // Named parameters
    println!("Hello {name}, you are {age} years old");
    
    // Debug printing (for development)
    let numbers = vec![1, 2, 3];
    println!("Numbers: {:?}", numbers);
}
```

---

## Comments

```rust
// Single line comment

/* Multi-line comment
   spanning several lines */

/// Documentation comment for functions
/// These show up in generated docs
fn documented_function() {
    //! Inner doc comment (less common)
    
    let x = 5; // Inline comment
}
```

---

## Putting It Together

Here's a simple example combining everything:

```rust
/// Calculates compound interest
fn calculate_interest(principal: f64, rate: f64, years: u32) -> f64 {
    let mut amount = principal;
    
    // Compound annually
    for _year in 1..=years {
        amount = amount * (1.0 + rate);
    }
    
    amount - principal // Return the interest earned
}

fn main() {
    let initial = 1000.0;
    let annual_rate = 0.05; // 5%
    let duration = 3;
    
    let interest = calculate_interest(initial, annual_rate, duration);
    
    if interest > 150.0 {
        println!("Great return! You earned ${:.2}", interest);
    } else {
        println!("Modest return: ${:.2}", interest);
    }
}
```

---

## Solana-Specific Context

In Solana programs, you'll commonly see:

```rust
use solana_program::{
    account_info::AccountInfo,
    entrypoint::ProgramResult,
    pubkey::Pubkey,
    msg,
};

// Entry point function
fn process_instruction(
    program_id: &Pubkey,        // Reference to program ID
    accounts: &[AccountInfo],   // Slice of accounts
    instruction_data: &[u8],    // Byte slice of data
) -> ProgramResult {           // Result type for errors
    
    msg!("Program invoked");    // Logging macro
    
    // Your program logic here
    
    Ok(()) // Return success
}
```

<Callout type="info">
Notice the `&` symbols? Those are references - we'll cover them in the next lesson. For now, just know they let you use data without taking ownership of it.
</Callout>

---

## Practice Exercise

Try writing a function that:
1. Takes two `u64` parameters
2. Returns the larger of the two numbers
3. Prints a message about which number was larger

```rust
// Your solution here
fn find_maximum(a: u64, b: u64) -> u64 {
    // Implement this function
}
```

<details>
<summary>Solution</summary>

```rust
fn find_maximum(a: u64, b: u64) -> u64 {
    if a > b {
        println!("{} is larger than {}", a, b);
        a
    } else if b > a {
        println!("{} is larger than {}", b, a);
        b
    } else {
        println!("Both numbers are equal: {}", a);
        a
    }
}
```

</details>

---

## Key Takeaways

- Variables are immutable by default, use `mut` to make them changeable
- Functions use `fn` keyword and can return values without explicit `return`
- Expressions without semicolons are returned from functions
- Use `println!` for output and `{:?}` for debug printing
- Control flow works similarly to other languages but with Rust's expression syntax

<Callout type="info">
You now know enough Rust syntax to read basic Solana programs! Next, we'll learn about structs and enums - the building blocks for organizing data in Solana programs.
</Callout>